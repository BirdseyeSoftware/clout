;; This file was generated with dalap-cljsbuild from
;;
;; src/clj/clout/core.clj @ Sat Dec 01 04:45:07 UTC 2012
;;
(ns clout.core "Library for parsing the Rails routes syntax." (:require [goog.string :as gstring] [clojure.string :as string] [goog.Uri :as uri]))
(do (defn re-matcher [re s] (if-let [matcher (.exec re s)] (do (set! (.-matches matcher) (fn [] true)) (set! (.-lookingAt matcher) (fn [] true)) (set! (.-groupCount matcher) (fn [] (- (.-length matcher) 1))) (set! (.-group matcher) (fn [i] (aget matcher (int i)))) (set! (.-end matcher) (fn [] (let [lastMatch (aget matcher (.groupCount matcher)) lastPos (.lastIndexOf s lastMatch)] (+ lastPos (.-length lastMatch))))) matcher) (let [matcher (js-obj)] (set! (.-matches matcher) (fn [] false)) (set! (.-lookingAt matcher) (fn [] false)) (set! (.-groupCount matcher) (fn [] 0)) (set! (.-group matcher) (fn [i] (throw (js/Error. "Illegal state exception")))) (set! (.-end matcher) (fn [i] (throw (js/Error. "Illegal state exception")))) matcher))))
(def re-chars (set "\\.*+|?()[]{}$^"))
(defn- re-escape "Escape all special regex chars in a string." [s] (string/escape s (fn* [p1__3764#] (if (re-chars p1__3764#) (str \\ p1__3764#)))))
(defn re-groups* "More consistant re-groups that always returns a vector of groups, even if\n  there is only one group." [matcher] (for [i (range (.groupCount matcher))] (.group matcher (int (inc i)))))
(defn path-decode "Decode a path segment in a URI. Defaults to using UTF-8 encoding." ([path] (path-decode path "UTF-8")) ([path encoding] (-> (string/replace path "+" (gstring/urlEncode "+")) (gstring/urlDecode))))
(defn- assoc-vec "Associate a key with a value. If the key already exists in the map, create a\n  vector of values." [m k v] (assoc m k (if-let [cur (m k)] (if (vector? cur) (conj cur v) [cur v]) v)))
(defn- assoc-keys-with-groups "Create a hash-map from a series of regex match groups and a collection of\n  keywords." [groups keys] (reduce (fn [m [k v]] (assoc-vec m k v)) {} (map vector keys groups)))
(defn- request-url "Return the complete URL for the request." [request] (str (name (:scheme request)) "://" (get-in request [:headers "host"]) (:uri request)))
(defn- path-info "Return the path info for the request." [request] (or (:path-info request) (:uri request)))
(defprotocol Route (route-matches [route request] "If the route matches the supplied request, the matched keywords are\n    returned as a map. Otherwise, nil is returned."))
(defrecord CompiledRoute [re keys absolute?] Route (route-matches [route request] (let [path-info (if absolute? (request-url request) (path-info request)) matcher (re-matcher re path-info)] (if (.matches matcher) (assoc-keys-with-groups (map path-decode (re-groups* matcher)) keys)))))
(defn- lex-1 "Lex one symbol from a string, and return the symbol and trailing source." [src clauses] (some (fn [[re action]] (let [matcher (re-matcher re src)] (if (.lookingAt matcher) [(if (fn? action) (action matcher) action) (subs src (.end matcher))]))) (partition 2 clauses)))
(defn- lex "Lex a string into tokens by matching against regexs and evaluating\n   the matching associated function." [src & clauses] (loop [results [] src src clauses clauses] (if-let [[result src] (lex-1 src clauses)] (let [results (conj results result)] (if (= src "") results (recur results src clauses))))))
(defn- absolute-url? "True if the path contains an absolute or scheme-relative URL." [path] (boolean (re-matches #"(https?:)?//.*" path)))
(defn route-compile "Compile a path string using the routes syntax into a uri-matcher struct." ([path] (route-compile path {})) ([path regexs] (let [splat #"\*" word #":([\p{L}_][\p{L}_0-9-]*)" literal #"(:[^\p{L}_*]|[^:*])+" word-group (fn* [p1__3765#] (keyword (.group p1__3765# 1))) word-regex (fn* [p1__3766#] (regexs (word-group p1__3766#) "[^/,;?]+"))] (CompiledRoute. (re-pattern (apply str (lex path splat "(.*?)" #"^//" "https?://" word (fn* [p1__3767#] (str "(" (word-regex p1__3767#) ")")) literal (fn* [p1__3768#] (re-escape (.group p1__3768#)))))) (remove nil? (lex path splat :* word word-group literal nil)) (absolute-url? path)))))
(extend-type string Route (route-matches [route request] (route-matches (route-compile route) request)))